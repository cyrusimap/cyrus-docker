#!/usr/bin/env perl
use v5.34.0; # This is what macOS is shipping now. -- rjbs, 2025-03-14
use experimental 'signatures'; # Everything we use is stable and accepted.
use warnings;

package Cyrus::Docker::dar;

use utf8;

use Getopt::Long ();

BEGIN {
  my @missing;
  for my $prereq (
    # Core libraries, not really needed here, but keeping it simple...
    'Digest::SHA',
    'JSON::PP',

    'IPC::Run',
    'Path::Tiny',
    'Process::Status',
  ) {
    my $ok = eval "require $prereq; 1";
    push @missing, $prereq unless $ok;
  }

  if (@missing) {
    my $error = join qq{\n}, (
      "You're missing some required modules, please install them:",
      map {; "  $_" } @missing,
    );

    die "$error\n";
  }
}

use Digest::SHA qw(sha1_hex);
# use Getopt::Long::Descriptive;
use IPC::Run qw(run);
use JSON::PP;
use Path::Tiny;
use Process::Status;

my $MINIMUM_IMAGE_VERSION = 1;

binmode *STDOUT, ':encoding(utf-8)';
binmode *STDERR, ':encoding(utf-8)';

my $HELP = <<'END';
dar is a little program to help you use the Cyrus docker image for testing your
work in your own checkout of the cyrusimapd repository.

The idea is that it runs a do-nothing container that's ready to build and test
Cyrus, and then you can tell it to build and test Cyrus at your whim.  It will
only manage one container per checkout (as identified by absolute path).

The simplest thing to do is to run "dar smoke", which will start a container
(if needed), then configure, build, and test Cyrus using the "cyd smoke"
command packed inside the cyrus-docker image.  If you want to pass arguments to
smoke, you can run "dar smoke -- test1 test2 test3", for example.

You can run other cyd commands through dar.  If you want to get a shell and
look into what went wrong on your last test run, you can run "dar shell".  If
you want to run something other than a cyd command, use "dar run -- XYZ ABC" to
run XYZ ABC directly in the container.

dar will start a container just in time to run whatever command you want, and
will leave it running for more commands.  If you want to clean up the container
it's got running, run "dar prune".

If you want to start a container before running any particular commands, you
can run "dar start", which is mostly useful to allow you to pass "--image" to
specify an alternate image to use for the container.

The default image is ghcr.io/cyrusimap/cyrus-docker:nightly but you can set a
different default for all your uses of "dar" by creating the file
~/.cyrus-docker/config, which should contain a JSON object.  The only
meaningful key, for now, is "default_image", which provides an alternate
default image.
END

my $command = @ARGV ? shift(@ARGV) : 'help';

# turn --help into help, and support old-style "--prune" etc.
$command =~ s/\A--//;

my $ABS_CWD = path('.')->absolute;

my $CONFIG  = Cyrus::Docker::dar->load_config();

my $method = __PACKAGE__->can("do_" . $command);

unless ($method) {
  $method = __PACKAGE__->can('do_exec');
  unshift @ARGV, $command;
}

__PACKAGE__->$method([@ARGV]);

my sub emptyref {
  my $str = q{};
  return \$str;
}

sub do_help {
  print $HELP;
  return;
}

sub do_start ($class, $args) {
  # Generally, this should not fail..?
  die "error parsing arguments!\n" unless Getopt::Long::GetOptionsFromArray(
    $args,
    'keep'    => \my $opt_keep,
    'image=s' => \my $opt_image,
    'run-outside-clone' => \my $run_outside_clone,
  );

  #   [ 'keep',     'keep the container after exit' ],
  #   [ 'image=s',  'which image to use' ],
  #   [ 'run-outside-clone', 'run even if cwd is not a cyrus-imapd clone' ],

  unless (-e 'imap/imapd.c' || $run_outside_clone) {
    die <<~'END';
    The current directory doesn't appear to be a cyrus-imapd clone.  To run dar
    anyway, pass the --run-outside-clone switch.
    END
  }

  my $existing_container = $class->_existing_container;

  if ($existing_container) {
    unless ($existing_container->{State} eq 'exited') {
      # There are states other than running and exited, but we're going to
      # treat anything but "exited" as "still running" for now.
      die "❌ The container $existing_container->{Names} is already running!\n";
    }

    if ($existing_container->{Command} ne q{"cyd idle"}) {
      # I don't think this should ever happen either...
      die "❌ Weird: existing container isn't set to run cyd idle.  Giving up.\n";
    }

    say "⏳ Restarting container $existing_container->{Names} to idle.";
    run(
      [ 'docker', 'start', $existing_container->{ID} ],
      emptyref(),
      \my $container_id,
    );

    Process::Status->assert_ok("❌ Restarting container");
    return $existing_container;
  }

  my $name = $class->container_name_for_cwd;
  say "⏳ Starting container $name to idle.";

  my $image_specifier = $class->_requested_image($opt_image);

  {
    # Assert that we have the image.  If not, point user to "dar pull"
    run(
      [ 'docker', 'image', 'ls', '--format', 'json', $image_specifier ],
      emptyref(),
      \my $image_json_lines,
    );

    Process::Status->assert_ok("❌ Getting list of available images");

    chomp $image_json_lines;
    my @lines = split /\n/, $image_json_lines;

    @lines == 0
      && die qq{❌ The image $image_specifier isn't available.};

    @lines > 1
      && die qq{❌ $image_specifier matches more than one candidate image.};
  }

  my $image = $class->_get_image($image_specifier);

  my $image_version = $image->{Config}{Labels}{'org.cyrusimap.cyrus-docker.version'};

  unless ($image_version && $image_version >= $MINIMUM_IMAGE_VERSION) {
    # In the future, when we actually *use* this facility for something, we may
    # want to be more specific, like "you need v3 minimum" or "the following
    # commands will not work without v3" or whatever.  For now, "just update"
    # seems solid.
    die "❌ This container is too old for this version of dar.\n";
  }

  run(
    [
      'docker', 'run',
      '--detach',
      '--name', $name,
      '--mount', "type=bind,src=$ABS_CWD,dst=/srv/cyrus-imapd",
      ($opt_keep ? () : '--rm'),
      $image_specifier,
      qw( cyd idle )
    ],
    emptyref(),
    \my $container_id,
  );

  Process::Status->assert_ok("❌ Starting idle container");

  chomp $container_id;
  say "✅ Container started, id: $container_id";

  my $container = $class->_existing_container;

  unless ($container) {
    # This is another one of those "should never happen" things…
    die "❌ The container was started, but now can't be found!\n"
  }

  # We need the git-version.sh program to work, which means that "git describe"
  # needs to work in the container's git repo, but it will be running as root,
  # so git will complain about mismatched ownership unless we mark this
  # directory safe. -- rjbs, 2024-12-27
  run([
    qw( docker exec ), $container->{ID},
    qw( git config --global --add safe.directory /srv/cyrus-imapd ),
  ]);

  Process::Status->assert_ok("❌ Fixing git permissions in container");

  return $class->_existing_container;
}

sub do_prune ($class, $args) {
  @$args && die "❌ You can't supply a command to run with --prune.\n";

  my $container = $class->_existing_container;

  unless ($container) {
    say "✅ Nothing to clean up.";
    return;
  }

  run(
    [ qw( docker inspect ), $container->{ID} ],
    emptyref(),
    \my $inspect_json,
  );

  Process::Status->assert_ok("❌ Inspecting stopped container");

  my $inspect = decode_json($inspect_json);
  my $autoremove = $inspect->[0]{HostConfig}{AutoRemove};

  run(
    [ qw( docker container stop ), $container->{ID} ],
    emptyref(),
    emptyref(),
  );

  Process::Status->assert_ok("❌ Stopping existing container");

  say "✅ Container stopped.";

  unless ($autoremove) {
    run([ qw( docker container rm ), $container->{ID} ]);
    Process::Status->assert_ok("❌ Removing stopped container");
  }
}

sub do_exec ($class, $args) {
  my $container = $class->_existing_container;

  unless ($container && $container->{State} eq 'running') {
    die qq{❌ You don't have a running container.  You'll want to run "dar start".\n};
  }

  if ($container->{Command} ne q{"cyd idle"}) {
    # I don't think this should ever happen either...
    die "❌ Weird: existing container isn't running cyd idle.  Giving up.\n";
  }

  say "⏳ Executing command in container $container->{ID}...";

  my @to_run = @$args && $args->[0] eq 'run'  ? ($args->@[1..$#$args])
             : @$args                         ? ('cyd', @$args)
             :                                  ('cyd', 'shell');

  exec(
    qw( docker exec --workdir /srv/cyrus-imapd -ti ),
    $container->{ID},
    @to_run,
  );
}

sub _requested_image ($class, $opt_image) {
  state $uname  = `uname -a`;
  state $suffix = $uname =~ /\barm64\b/ ? '-arm' : q{};

  return $opt_image
      // $CONFIG->{default_image}
      // "ghcr.io/cyrusimap/cyrus-docker:bookworm$suffix";
}

sub _get_image ($class, $image_specifier) {
  run(
    [ 'docker', 'image', 'inspect', $image_specifier ],
    emptyref(),
    \my $json,
  );

  Process::Status->assert_ok("❌ Inspecting image");

  my $data = decode_json($json);

  if (@$data > 1) {
    die "❌ More than one image description came back from docker image inspect?!\n";
  }

  return $data->[0];
}

sub _get_containers {
  my %container_named = do {
    my (@lines) = `docker container list -a --format json`;

    Process::Status->assert_ok("❌ Getting container list");
    chomp @lines;

    # Names?  Plural?  I'm gonna guess that if you do weird things you can get
    # "name1,name2" but for now I will not worry about it -- rjbs, 2024-12-24
    map {; $_->{Names} => $_ } map { decode_json($_) } @lines;
  };

  return \%container_named;
}

sub _existing_container ($class) {
  my $containers = $class->_get_containers;
  return $containers->{ $class->container_name_for_cwd };
}

sub container_name_for_cwd {
  my $digest = sha1_hex("$ABS_CWD");
  return "cyd-" . substr($digest, 0, 12);
}

sub load_config {
  my $config_file = path('~/.cyrus-docker')->mkdir->child('config');
  return {} unless -e $config_file;
  return decode_json($config_file->slurp);
}
